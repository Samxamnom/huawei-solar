# Telegraf config
[agent]
  interval = "5s"
  round_interval = true
  metric_batch_size = 1000
  metric_buffer_limit = 10000
  collection_jitter = "0s"
  flush_interval = "5s"
  flush_jitter = "0s"
  precision = "0s"
  hostname = ""
  omit_hostname = false

# Configuration for sending metrics to InfluxDB 2.0
# [[outputs.influxdb_v2]]
#   urls = ["http://influxdb:8086"]

#   token = "$TELEGRAF_TOKEN"
#   organization = "$TELEGRAF_ORG"
#   bucket = "$TELEGRAF_BUCKET"
[[outputs.postgresql]]
  connection = "postgres://${DB_USER}:${DB_PASS}@${DB_HOST}/${DB_NAME}"

# Retrieve data from MODBUS slave devices
[[inputs.modbus]]
  name = "Huawai Inverter"
  timeout = "1s"

  ## Maximum number of retries and the time to wait between retries when a slave-device is busy.
  # busy_retries = 0
  # busy_retries_wait = "100ms"

  controller = "tcp://192.168.200.1:6607"

  configuration_type = "request"
  ## Per request definition
  ##

  ## Define a request sent to the device
  ## Multiple of those requests can be defined. Data will be collated into metrics at the end of data collection.
  [[inputs.modbus.request]]
    ## Holding example
    ## All of those examples will result in FLOAT64 field outputs
    slave_id = 0
    byte_order = "ABCD"
    register = "holding"
    fields = [
      { address=30070, name="model_id",  type="UINT16" },
      { address=30071, name="pv_count",  type="UINT16" },
      { address=30072, name="mpp_count", type="UINT16" },
      { address=30073, name="rated_power", type="UINT32", measurement="kW", scale=0.001},
      { address=30075, name="max_active_power", type="UINT32", measurement="kW", scale=0.001},
      { address=30077, name="max_apparent_power", type="UINT32", measurement="kVA", scale=0.001},
      { address=30079, name="max_reactive_power_to_grid", type="INT32", measurement="kVar", scale=0.001},
      { address=30081, name="max_reactive_power_from_grid", type="INT32", measurement="kVar", scale=0.001},
      { address=32000, name="state1", type="UINT16", measurement="bit"},
      { address=32002, name="state2", type="UINT16", measurement="bit"},
      { address=32003, name="state3", type="UINT32", measurement="bit"},
      { address=32016, name="pv1_voltage", type="INT16", measurement="V", scale=0.1},
      { address=32017, name="pv1_current", type="INT16", measurement="A", scale=0.01},
      { address=32064, name="input_power", type="INT32", measurement="kW", scale=0.001},
      { address=32078, name="peak_active_power_day", type="INT32", measurement="kW", scale=0.001},
      { address=32080, name="active_power", type="INT32", measurement="kW", scale=0.001},
      { address=32082, name="reactive_power", type="INT32", measurement="kVar", scale=0.001},
      { address=32087, name="internal_temperature", type="INT16", measurement="Celsius", scale=0.1},
      { address=32106, name="accumulated_energy_yield", type="UINT32", measurement="kWh", scale=0.01},
      { address=32114, name="daily_energy_yield", type="UINT32", measurement="kWh", scale=0.01}
    ]

    [inputs.modbus.request.tags]
      machine = "Solar Inverter 1"

  ## Enable workarounds required by some devices to work correctly
  [inputs.modbus.workarounds]
    pause_after_connect = "1000ms"
    ## Pause between read requests sent to the device. This might be necessary for (slow) serial devices.
    pause_between_requests = "1000ms"
    ## Close the connection after every gather cycle. Usually the plugin closes the connection after a certain
    ## idle-timeout, however, if you query a device with limited simultaneous connectivity (e.g. serial devices)
    ## from multiple instances you might want to only stay connected during gather and disconnect afterwards.
    # close_connection_after_gather = false
